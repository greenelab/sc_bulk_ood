# -*- coding: utf-8 -*-
"""rotated_example_ssDIVA_mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qWnDztzY2nScl9RoBHwF2tkd7YcDwGiB

# **Intro**
In this notebook I set up semi-supervised VAE that disentangles the rotation and digits of MNIST numbers. 
This is almost identical to "[DIVA: DOMAIN INVARIANT VARIATIONAL AUTOENCODERS](https://arxiv.org/pdf/1905.10427.pdf)".
To breifly describe the model, we have 3 independent encoders that encode for different sources of variation: rotation, digit, and everything else (slack).
To enforce this disentanglement, there are classification losses on the rotation and digit embeddings.
The embeddings are then concatenated together and used as input to a joint decoder.
When used in the semi-supervised mode, the classification loss is calculated by comparing the classifier output to the latent digit representation.
The model is depicted below.

![Screen Shot 2021-08-30 at 10.48.27.png](data:image/png;base64,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jOTZs2cEEEAAAQQQQAABBBBAAAEEEBikAEHGIMF4OgIIIIAAAggggAACCCCAAAIIJE+AICN59uwZAQQQQAABBBBAAAEEEEAAAQQGKUCQMUgwno4AAggggAACCCCAAAIIIIAAAskTIMhInj17RgABBBBAAAEEEEAAAQQQQACBQQoQZAwSjKcjgAACCCCAAAIIIIAAAggggEDyBAgykmfPnhFAAAEEEEAAAQQQQAABBBBAYJACBBmDBOPpCCCAAAIIIIAAAggggAACCCCQPAGCjOTZs2cEEEAAAQQQQAABBBBAAAEEEBikAEHGIMF4OgIIIIAAAggggAACCCCAAAIIJE+AICN59uwZAQQQQAABBBBAAAEEEEAAAQQGKUCQMUgwno4AAggggAACCCCAAAIIIIAAAskTIMhInj17RgABBBBAAAEEEEAAAQQQQACBQQoQZAwSjKcjgAACCCCAAAIIIIAAAggggEDyBAgykmfPnhFAAAEEEEAAAQQQQAABBBBAYJACBBmDBOPpCCCAAALxFWhtbbV77rlnUBvNzs62MWPGWHFxsZWUlFhVVZVVV1dbRUXFoLbDkxEIokBbW5u9//3vD3Xtta99rd12222h77mBAAIIIIBAugsQZKT7GeT4EUAAgTQXOHPmjC1atCguvVi5cqV94hOfsPXr18dle2wkdQS6urrsU5/6lLsgv+WWW1LnwJJwJJs2bbLvfe979pnPfCbq3puammz+/Pmhx/7lX/7F7rrrrtD33EAAAQQQQCDdBQgy0v0McvwIIIBAmgvEM8gQRVZWlt177732rne9K81lOHxf4Kc//al96EMfspMnT9r3v/99u/322/2HMuqrAgq9t7/73e/a6tWr7Ve/+lXU/hNkRGXhTgQQQACBAAkQZAToZNIVBBBAIB0FIoOMOXPm2Itf/OJ+u/LUU0/Z+fPn7fjx47Z//353gRv+AoUZ999/v91xxx3hd3M7DQW2b99uz3zmM0NHnslBxqtf/Wp7+OGHncWaNWsIMkLvCm4ggAACCGSaAEFGpp1x+osAAgikmEBkkPGCF7zAhRCxHub169ftBz/4gX384x+3Y8eOhV42Y8YMq6urs1GjRoXu40b6CegcPvvZzw4deCYHGa985Svt0UcfdRb9BRmXL192U098NE21WrBggf8tXxFAAAEEEEh7AYKMtD+FdAABBBBI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)


The experimental set-up is as follows:
The numbers are rotated 0, 15, 30, 45, 60, and 75 degrees. 
The model differentiates domains (rotations, referred to as *labels* in the code) from predicted values (digits, , referred to as *Y* in the code). 
The idea is to be able to provide correct labels in a new domain. 
The semi-supervision section has a new domain (30 degrees) without a Y (no digit).


This is analogous to the following situation: 
single-cell profiles where a patient or sequencing method is the domain (noise we would like to remove) and cell type (the label) is what we would like to predict.
This is done in a semi-supervised fashion because we would like to use bulk data in addition to single-cell.
However, bulk data is assumed to be a sum over many cell-types (i.e. we don't know the labels).
There is one simplification in this approach -- we predict a single-cell type for now.
Realistically, we predict a continuous vector of cell-type proportions.
Currently, we predict a 1-hot representation of cell-type identity.

Using both of these sources of data we hope that we can work on OOD stuff.
We focus on interpolation, not extrapolation, but this is not directly done in this notebook.

This code was based off of DIVA's codebase: https://github.com/AMLab-Amsterdam/DIVA

Semi-supervised training method was take from here:
And this tutorial: https://github.com/bjlkeng/sandbox/tree/master/notebooks/vae-semi_supervised_learning with an awesome accomanying blogpost: https://bjlkeng.github.io/posts/semi-supervised-learning-with-variational-autoencoders/

# **Github / VM setup**

To integrate Colab with github, we need to do some setup first.
If you want this to integrate with your own github repo, you will need to create a `secrets` folder that contain your public and private key, and register this to access you github repo. Check `setup.sh` for more details.
"""

import os, sys

NB_ROOT_PATH = '/content/drive/MyDrive/Colab Notebooks/checkouts/sc_bulk_ood'
sys.path.append('/content/drive/MyDrive/Colab Notebooks/checkouts/sc_bulk_ood')

# Commented out IPython magic to ensure Python compatibility.
# prelude: set up git, etc.
# %cd {NB_ROOT_PATH}
!( source setup.sh )



# Commented out IPython magic to ensure Python compatibility.
# %%bash
# # do your git operations here
# 
# git status

"""# **Imports**"""

# Commented out IPython magic to ensure Python compatibility.
# general imports
import warnings
import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, Dense, Lambda, Flatten, Softmax, ReLU, ELU, LeakyReLU
from keras.layers.merge import concatenate as concat
from tensorflow.keras.models import Model, Sequential
from tensorflow.keras import backend as K
from tensorflow.keras.losses import mean_absolute_error, mean_squared_error
from tensorflow.keras.datasets import mnist
from tensorflow.keras.activations import relu, linear
from tensorflow.keras.utils import to_categorical, normalize
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import Adam, SGD
import matplotlib.pyplot as plt
from scipy.spatial import distance_matrix
from scipy.spatial.distance import euclidean
from sklearn.model_selection import StratifiedShuffleSplit
from sklearn.metrics import accuracy_score
from PIL import Image

# Images, plots, display, and visualization
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import cv2
from sklearn.manifold import TSNE

# programming stuff
import time
import os
import pickle
from pathlib import Path

# Load the TensorBoard notebook extension
# %load_ext tensorboard

# load methods from other files
from mnist_preprocessing import generate_data as gd

# I disable eager execution ... forgot why
from tensorflow.python.framework.ops import disable_eager_execution
disable_eager_execution()

warnings.filterwarnings('ignore')
# %pylab inline

"""# **Load / Pre-process data**
Import + reshape the non-rotated MNIST data
"""

(X_train, Y_train), (X_test, Y_test) = mnist.load_data()
Y_train = to_categorical(Y_train)

print(X_train.shape)
print(X_test.shape)

X_train = X_train.astype('float32') / 255.
X_test = X_test.astype('float32') / 255.

n_pixels = np.prod(X_train.shape[1:])
X_train = X_train.reshape((len(X_train), n_pixels))
X_test = X_test.reshape((len(X_test), n_pixels))

print(Y_train)

"""Import + reshape and rotate MNIST data.
In our single-cell analogy, rotation is a treatment and the number value is a cell-type.
"""

(X_train_r, Y_train_r), (X_test_r, Y_test_r) = mnist.load_data()
Y_train_r = to_categorical(Y_train_r)
# now add in the rotation
def rotate_90(img):
  return cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)

def rotate_deg(in_img, angle):
  img = Image.fromarray(np.uint8(in_img) , 'L')
  img = img.rotate(angle)
  return np.asarray(img)

def rotate_data(X_train, Y_train, X_test, Y_test, angle):
  # rotate the training data
  X_train_15 = np.array([rotate_deg(xi, angle) for xi in X_train_r])
  Y_train_15 = Y_train

  # rotate the test data
  X_test_15 = np.array([rotate_90(xi) for xi in X_test_r])
  Y_test_15 = Y_test

  # reshape the data
  X_train_15 = X_train_15.astype('float32') / 255.
  X_test_15 = X_test_15.astype('float32') / 255.

  n_pixels = np.prod(X_train_15.shape[1:])
  X_train_15 = X_train_15.reshape((len(X_train_15), n_pixels))
  X_test_15 = X_test_15.reshape((len(X_test_15), n_pixels))

  return (X_train_15, Y_train_15, X_test_15, Y_test_15)

X_train_15, Y_train_15, X_test_15, Y_test_15 = rotate_data(X_train_r, Y_train_r, 
                                                           X_test_r, Y_test_r, 
                                                           angle = 15)
X_train_30, Y_train_30, X_test_30, Y_test_30 = rotate_data(X_train_r, Y_train_r, 
                                                           X_test_r, Y_test_r, 
                                                           angle = 30)
X_train_45, Y_train_45, X_test_45, Y_test_45 = rotate_data(X_train_r, Y_train_r, 
                                                           X_test_r, Y_test_r, 
                                                           angle = 45)
X_train_60, Y_train_60, X_test_60, Y_test_60 = rotate_data(X_train_r, Y_train_r, 
                                                           X_test_r, Y_test_r, 
                                                           angle = 60)
X_train_75, Y_train_75, X_test_75, Y_test_75 = rotate_data(X_train_r, Y_train_r, 
                                                           X_test_r, Y_test_r, 
                                                           angle = 75)

"""Demo the data, to make sure everything works"""

print("rotated 15")
plt.imshow(X_train_15[0].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()
print("rotated 30")
plt.imshow(X_train_30[0].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()
print("rotated 45")
plt.imshow(X_train_45[0].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()
print("rotated 60")
plt.imshow(X_train_60[0].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()
print("rotated 75")
plt.imshow(X_train_75[0].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()

"""# **Model Definition**

## Hyperparameters
"""

batch_size = 500
n_epoch = 75

alpha_rot = 1000000
alpha_prop = 100 

beta_kl_slack = 10
beta_kl_rot = 100
beta_kl_prop = 10

# the network dimensions are 784 > 512 > proportion_dim < 512 < 784
n_z = 10 # latent space size, one latent dimension PER MNIST digit
encoder_dim = 512 # dim of encoder hidden layer
decoder_dim = 512 # dim of encoder hidden layer
decoder_out_dim = 784 # dim of decoder output layer

activ = 'relu'
optim = Adam(learning_rate=0.001)

n_x = X_train.shape[1]
n_y = Y_train.shape[1]
n_label = 6  # 6 rotation angles
n_label_z = 64  # 64 dimensional representation of rotation

print(f"length of X {n_x} and length of y {n_y} and n_label {n_label}")

"""## Encoder"""

# declare the Keras tensor we will use as input to the encoder
X = Input(shape=(n_x,))
label = Input(shape=(n_label,))
props = Input(shape=(n_y,))

# concatenate input with the label 
inputs = X

# set up encoder network
# this is an encoder with 512 hidden layer
# Dense is a functor, with given initializations (activation and hidden layer dimension)
# After initialization, the functor is returned and inputs is used as an arguement
encoder_s = Dense(encoder_dim, activation=activ, name="encoder_slack")(inputs)
encoder_p = Dense(encoder_dim, activation=activ, name="encoder_prop")(inputs)
encoder_r = Dense(encoder_dim, activation=activ, name="encoder_rot")(inputs)

# now from the hidden layer, you get the mu and sigma for 
# the latent space

mu_slack = Dense(n_z, activation='linear', name = "mu_slack")(encoder_s)
l_sigma_slack = Dense(n_z, activation='linear', name = "sigma_slack")(encoder_s)

mu_prop = Dense(n_z, activation='linear', name = "mu_prop")(encoder_p)
l_sigma_prop = Dense(n_z, activation='linear', name = "sigma_prop")(encoder_p)

mu_rot = Dense(n_label_z, activation='linear', name = "mu_rot")(encoder_r)
l_sigma_rot = Dense(n_label_z, activation='linear', name = "sigma_rot")(encoder_r)

"""## Latent Space"""

# now we need the sampler from mu and sigma
def sample_z(args):
    mu, l_sigma, n_z = args
    eps = K.random_normal(shape=(batch_size, n_z), mean=0., stddev=1.)
    return mu + K.exp(l_sigma / 2) * eps


# Sampling latent space
z_slack = Lambda(sample_z, output_shape = (n_z, ), name="z_samp_slack")([mu_slack, l_sigma_slack, n_z])
z_prop = Lambda(sample_z, output_shape = (n_z, ), name="z_samp_prop")([mu_prop, l_sigma_prop, n_z])
z_rot = Lambda(sample_z, output_shape = (n_label, ), name="z_samp_rot")([mu_rot, l_sigma_rot, n_label_z])

z_concat = concat([z_slack, z_prop, z_rot])

"""## Decoder + Classifiers"""

def null_f(args):
    return args

###### DECODER
# set up decoder network
# this is a decoder with 512 hidden layer
decoder_hidden = Dense(decoder_dim, activation=activ, name = "decoder_h1")

# final reconstruction
decoder_out = Dense(decoder_out_dim, activation='sigmoid', name = "decoder_out")

d_in = Input(shape=(n_z+n_z+n_label_z,))
d_h1 = decoder_hidden(d_in)
d_out = decoder_out(d_h1)

# set up the decoder part that links to the encoder
h_p = decoder_hidden(z_concat)
outputs = decoder_out(h_p)

###### Proportions classifier
# this is the proportions we try to estimate
decoder_props = Softmax(name = "mu_prop_pred")

# we use this to get sigma to do sampling later
decoder_sigma = Lambda(null_f, name = "l_sigma_prop_pred")

prop_outputs = decoder_props(mu_prop)
sigma_outputs_p = decoder_sigma(l_sigma_prop)


###### Rotations classifier
# this is the rotation we try to estimate
rot_h1 = ReLU(name = "rot_h1")
rot_h2 = Dense(n_label, activation='linear', name = "rot_h2")
rot_props = Softmax(name = "mu_rot_pred")
decoder_sigma_r = Lambda(null_f, name = "l_sigma_rot_pred")


rot_1_out = rot_h1(z_rot)
rot_2_out = rot_h2(rot_1_out)
rotation_outputs = rot_props(rot_2_out)
sigma_outputs_r = decoder_sigma_r(l_sigma_rot)

"""## Loss"""

def vae_loss(y_true, y_pred):
    recon = K.sum(K.binary_crossentropy(y_true, y_pred), axis=-1)
    kl_prop = beta_kl_prop * K.sum(K.exp(l_sigma_prop) + K.square(mu_prop) - 1. - l_sigma_prop, axis=-1)
    kl_rot = beta_kl_rot * K.sum(K.exp(l_sigma_rot) + K.square(mu_rot) - 1. - l_sigma_rot, axis=-1)
    kl_slack = beta_kl_slack * K.sum(K.exp(l_sigma_slack) + K.square(mu_slack) - 1. - l_sigma_slack, axis=-1)
    return recon + kl_prop + kl_rot + kl_slack

def KL_loss(y_true, y_pred):
	return(beta_kl * K.sum(K.exp(l_sigma) + K.square(mu) - 1. - l_sigma, axis=1))

def recon_loss(y_true, y_pred):
	return K.sum(K.binary_crossentropy(y_true, y_pred), axis=-1)


def prop_loss(y_true, y_pred):
	return K.sum(K.binary_crossentropy(y_true, y_pred), axis=-1) * alpha_prop


def prop_loss_unknown_iterate(y_true, y_pred):
  total_loss = 0
  for idx in range(0, 10):
    y_shuffle = np.zeros((500, 10))
    y_shuffle[:,idx] = 1
    y_temp = tf.convert_to_tensor(y_shuffle, dtype=tf.float32)
    total_loss = total_loss + K.sum(K.binary_crossentropy(y_temp, y_pred), axis=-1)
  return total_loss * alpha_prop

def prop_loss_unknown(y_true, y_pred):
  return K.sum(K.binary_crossentropy(prop_outputs, y_pred), axis=-1) * alpha_prop


def class_loss(y_true, y_pred):
    recon = K.sum(K.binary_crossentropy(y_true, y_pred), axis=-1)*alpha_rot
    return recon

"""## Make the computational graph"""

known_prop_vae = Model(X, [outputs, prop_outputs, rotation_outputs, sigma_outputs_p])
unknown_prop_vae = Model(X, [outputs, prop_outputs, rotation_outputs])

known_prop_vae.compile(optimizer=optim, loss=[vae_loss, prop_loss, class_loss, None]) #, metrics = [KL_loss, recon_loss])
unknown_prop_vae.compile(optimizer=optim, loss=[vae_loss, prop_loss_unknown, class_loss]) #, metrics = [KL_loss, recon_loss])


encoder = Model(X, [z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot])

decoder = Model(d_in, d_out)

print(known_prop_vae.summary())
print(unknown_prop_vae.summary())



"""# **Experimental Setup**

Now lets train and evaluate the model.
First we train with only some proportions of rotated 3's..
We will then decrease the proportion of rotated 3's in samples from 0.5 to 0.
"""

# helper methods for evaluation
def sum_abs_error(y_pred, y_true):
  return sum(abs(y_pred - y_true))

def mean_abs_error(y_pred, y_true):
  return np.mean(abs(y_pred - y_true))

"""Setup the data so that we remove all the examples with a high proportion of rotated 3's"""

##################################################
#####. Design the experiment
##################################################

## 30 is unlabeled
## we test on 75

X_full = np.concatenate([X_train, X_train_15, X_train_30, X_train_45, X_train_60, X_train_75])
Y_full = np.concatenate([Y_train, Y_train_15, Y_train_30, Y_train_45, Y_train_60, Y_train_75])

print(X_full.shape)

### also create the condition label (degrees = label; 0=0, 15=1, 30=2, ... 75=5) 
n_train = Y_train.shape[0]
Label_full = np.concatenate([np.full(n_train, 0), np.full(n_train, 1),
                              np.full(n_train, 2), np.full(n_train, 3),
                              np.full(n_train, 4), np.full(n_train, 5)], axis=0)
label_full = to_categorical(Label_full)

# indexes for the training, 30 and 75
idx_train = np.where(np.logical_and(Label_full!=2, Label_full!=5))[0]
idx_30 = np.where(Label_full==2)[0]
idx_75 = np.where(Label_full==5)[0]

print("rotated 30")
plt.imshow(X_full[idx_30[0],].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()
print("rotated 75")
plt.imshow(X_full[idx_75[0]].reshape(28, 28), cmap = plt.cm.gray), axis('off')
plt.show()


# for unknown proportions; i.e. 30 degrees
X_unkp = X_full[idx_30,]
label_unkp = label_full[idx_30,]
y_unkp = Y_full[idx_30,]

# for known proportions
X_kp = X_full[idx_train,]
label_kp = label_full[idx_train,]
y_kp = Y_full[idx_train,]


# test; i.e. 30 degrees
X_75 = X_full[idx_75,]
label_75 = label_full[idx_75,]
y_75 = Y_full[idx_75,]



# now take a subsample of the full dataset
unkp_size = 50000
kp_size = 50000
unkp_rand_idx = np.random.choice(X_unkp.shape[0], size=unkp_size, replace=False)
kp_rand_idx = np.random.choice(X_kp.shape[0], size=kp_size, replace=False)

"""# **Training**

Here we train using both the known and unknown cell-type proportions.
The labeled data is repeated in order to match the dimension of the unlabeled data so that they have the same batch size.
This code is taken from https://github.com/bjlkeng/sandbox/blob/master/notebooks/vae-semi_supervised_learning/vae-m2-fit-mnist.ipynb
"""

from tqdm import tnrange, tqdm_notebook


def fit_model(X_unknown_prop, label_unknown_prop, X_known_prop, Y_known_prop, label_known_prop, epochs):
    assert len(X_known_prop) % len(X_unknown_prop) == 0, \
            (len(X_unknown_prop), batch_size, len(X_known_prop))
    start = time.time()
    history = []
    
    for epoch in tnrange(epochs):
        labeled_index = np.arange(len(X_known_prop))
        np.random.shuffle(labeled_index)

        # Repeat the unlabeled data to match length of labeled data
        unlabeled_index = []
        for i in range(len(X_known_prop) // len(X_unknown_prop)):
            l = np.arange(len(X_unknown_prop))
            np.random.shuffle(l)
            unlabeled_index.append(l)
        unlabeled_index = np.concatenate(unlabeled_index)
        
        batches = len(X_unknown_prop) // batch_size
        with tnrange(batches, leave=False) as pbar:
            for i in range(batches):
                # Labeled
                index_range =  labeled_index[i * batch_size:(i+1) * batch_size]
                loss = known_prop_vae.train_on_batch(X_known_prop[index_range], 
                                                      [X_known_prop[index_range], Y_known_prop[index_range], label_known_prop[index_range]])
                
                # Unlabeled
                y_shuffle = np.identity(10, dtype=np.float32)
                for idx in range(0, 49):
                  y_shuffle = np.vstack((y_shuffle, np.identity(10, dtype=np.float32)))
                #np.random.shuffle(y_shuffle)
                y_shuffle = np.zeros((batch_size, 10))
                y_shuffle[:,0] = 1
                index_range =  unlabeled_index[i * batch_size:(i+1) * batch_size]
                loss += [unknown_prop_vae.train_on_batch(X_unknown_prop[index_range], 
                                                         [X_unknown_prop[index_range], y_shuffle, label_unknown_prop[index_range]])]


                pbar.desc = 'Loss: %s' % loss
                history.append(loss)
                
                pbar.update(1)
    
   
    done = time.time()
    elapsed = done - start
    print("Elapsed: ", elapsed)
    
    return history

"""Now train"""

# X_unknown_prop, label_unknown_prop, X_known_prop, Y_known_prop, label_known_prop
history = fit_model(X_unkp[unkp_rand_idx,:],
                    label_unkp[unkp_rand_idx,:],
                    X_kp[kp_rand_idx,:], 
                    y_kp[kp_rand_idx,:],
                    label_kp[kp_rand_idx,:], epochs=n_epoch)

print(X_75[0].shape) 
print(y_75[0].shape)


z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(X_75, batch_size=batch_size)
test_error = [mean_abs_error(mu_prop[idx], y_75[idx]) 
                  for idx in range(0, X_75.shape[1])]

print(f"mean test_error: {np.round(np.mean(test_error), decimals=3)}\n"
      f"median test_error: {np.round(np.median(test_error), decimals=3)}\n"
      f"max test_error: {np.round(np.max(test_error), decimals=3)}")

"""# **Inspect the output**

We will take two examples from our training and see how well it reconstructs.
We first look at the ground truth so we know what we should expect.
"""

plot_idx = 1

plt.imshow(X_unkp[plot_idx].reshape(28, 28), cmap = plt.cm.gray)
plt.show()
print(y_unkp[plot_idx])
print(label_unkp[plot_idx])

"""## TSNE unseen data (75 degrees)

Now that we know what is expected, let's see what we get from the model. We find that out of our encoder, after applying ReLU, we get pretty close to the expected proportions.
"""

# plot proportions on unseen DATA
X_temp = X_full[idx_75,]

z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(X_temp, batch_size=batch_size)
z_test = mu_prop
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full[idx_75,]
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

"""## TSNE unlabeled data  (30 degrees)"""

# plot proportions on unlabeled DATA
X_temp = X_full[idx_30,]

z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(X_temp, batch_size=batch_size)
z_test = mu_prop
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full[idx_75,]
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

"""## TSNE All data (0-75)"""

# plot proportions on ALL DATA
X_temp = X_full

z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(X_temp, batch_size=batch_size)
z_test = mu_prop
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

# plot rotations on digit embedding
# to see if rotation+digit are entangled
plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Label_temp = Label_full
plot_df['label'] = Label_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="label",
    palette=sns.color_palette("hls", 6),
    legend="full",
    alpha=0.3
)

# plot rotation
z_test = z_rot
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_label_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))


plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Label_temp = Label_full
plot_df['label'] = Label_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="label",
    palette=sns.color_palette("hls", 6),
    legend="full",
    alpha=0.3
)

# plot digits on rotation embedding
# to see if rotation+digit are entangled

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

"""## TSNE Training data"""

# plot proportion latent space of training data
X_temp = X_full[idx_train,]

z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(X_temp, batch_size=batch_size)
z_test = mu_prop
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))


plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Label_temp = Label_full[idx_train]
plot_df['label'] = Label_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="label",
    palette=sns.color_palette("hls", 4),
    legend="full",
    alpha=0.3
)

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full[idx_train]
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

# plot rotation
z_test = z_rot
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_label_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))


plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Label_temp = Label_full
plot_df['label'] = Label_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="label",
    palette=sns.color_palette("hls", 4),
    legend="full",
    alpha=0.3
)

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full[idx_train]
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

# plot remaining variance
z_test = z_slack
encodings= np.asarray(z_test)
encodings = encodings.reshape(X_temp.shape[0], n_z)
tsne_idx = np.random.choice(encodings.shape[0], size=5000, replace=False)


time_start = time.time()
tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
tsne_results = tsne.fit_transform(encodings[tsne_idx,:])
print('t-SNE done! Time elapsed: {} seconds'.format(time.time()-time_start))


plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Label_temp = Label_full[idx_train]
plot_df['label'] = Label_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="label",
    palette=sns.color_palette("hls", 4),
    legend="full",
    alpha=0.3
)

plot_df = pd.DataFrame(tsne_results[:,0:2])
print(tsne_results.shape)
print(plot_df.shape)
plot_df.columns = ['tsne_0', 'tsne_1']
Y_temp = Y_full[idx_train]
Y_temp = np.argmax(Y_temp, axis=1)
plot_df['Y'] = Y_temp[tsne_idx]

sns.scatterplot(
    x="tsne_0", y="tsne_1",
    data=plot_df,
    hue="Y",
    palette=sns.color_palette("hls", 10),
    legend="full",
    alpha=0.3
)

"""# **Generate Data**

Here we will sample from each latent space and reconstruct a rotated digit.
"""

def method_sample_z(args):
    mu, l_sigma, n_dim = args
    eps = np.random.normal(size=(batch_size*5, n_dim), loc=0., scale=1.)
    return mu + np.exp(l_sigma / 2) * eps

def sample_digit(digit_img, X_temp, Y_temp):
  digit_idx = np.where(Y_temp == digit_img)

  pred_input = X_temp[digit_idx[0],]
  rand_idx = np.random.choice(pred_input.shape[0], size=batch_size*5, replace=False)
  pred_input = pred_input[rand_idx]

  z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(pred_input, batch_size=batch_size)

  z_0_digit = method_sample_z([mu_prop, l_sigma_prop, n_z])
  z_0_digit = np.median(z_0_digit, axis=0)
  z_0_digit = z_0_digit.reshape((1,n_z))
  return(z_0_digit)

def sample_rotation(rot_idx, X_temp, Label_temp):
  rot_idx = np.where(Label_temp == rot_idx)

  pred_input = X_temp[rot_idx[0]]
  rand_idx = np.random.choice(pred_input.shape[0], size=batch_size*5, replace=False)
  pred_input = pred_input[rand_idx]

  z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(pred_input, batch_size=batch_size)

  z_0_digit = method_sample_z([mu_rot, l_sigma_rot, n_label_z])
  z_0_digit = np.median(z_0_digit, axis=0)
  z_0_digit = z_0_digit.reshape((1,n_label_z))
  return(z_0_digit)

def sample_slack(X_temp):

  pred_input = X_temp
  rand_idx = np.random.choice(pred_input.shape[0], size=batch_size*5, replace=False)
  pred_input = pred_input[rand_idx]

  z_slack, mu_slack, l_sigma_slack, mu_prop, l_sigma_prop, z_rot, mu_rot, l_sigma_rot = encoder.predict(pred_input, batch_size=batch_size)

  z_0_digit = method_sample_z([mu_slack, l_sigma_slack, n_z])
  z_0_digit = np.median(z_0_digit, axis=0)
  z_0_digit = z_0_digit.reshape((1,n_z))
  return(z_0_digit)

# try it out
digit_img = 3
rot_idx = 0 # 0 degrees

Y_temp = Y_full[idx_train,]
Y_temp = np.argmax(Y_temp, axis=1)

X_temp = X_full[idx_train,]
Label_temp = Label_full[idx_train,]

# sample slack, prop, rot
slack_sample = sample_slack(X_temp)
z_0_digit = sample_digit(digit_img, X_temp, Y_temp)
rotate_1hot = sample_rotation(rot_idx, X_temp, Label_temp)

# put it together
pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

print(f"rotated {digit_img}")
plt.imshow(decoder.predict(pred_input).reshape(28,28), cmap = plt.cm.gray), axis('off')
plt.show()

# it is rotated
rot_idx = 4 # 60 degrees
rotate_1hot = sample_rotation(rot_idx, X_temp, Label_temp)
pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

print(f"rotated {digit_img}")
plt.imshow(decoder.predict(pred_input).reshape(28,28), cmap = plt.cm.gray), axis('off')
plt.show()

# plot reconstruction of training data
img_it = 0
sides = 10

Y_temp = Y_full[idx_train]
Y_temp = np.argmax(Y_temp, axis=1)

X_temp = X_full[idx_train,]

Label_temp = Label_full[idx_train,]

for i in range(0, sides):
    for j in np.unique(Label_temp):
        
        # slack, prop, rot
        slack_sample = sample_slack(X_temp)
        z_0_digit = sample_digit(i, X_temp, Y_temp)
        rotate_1hot = sample_rotation(j, X_temp, Label_temp)

        # put it together
        pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

        decoded = decoder.predict(pred_input)
        subplot(sides, 4, 1 + img_it)
        img_it +=1
        plt.imshow(decoded.reshape(28, 28), cmap = plt.cm.gray), axis('off')

plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=.2)
plt.show()


# plot reconstruction of all data
Y_temp = Y_full
Y_temp = np.argmax(Y_temp, axis=1)

X_temp = X_full

Label_temp = Label_full
img_it = 0
for i in range(0, sides):
    for j in range(0, 6):
        
        # slack, prop, rot
        slack_sample = sample_slack(X_temp)
        z_0_digit = sample_digit(i, X_temp, Y_temp)
        rotate_1hot = sample_rotation(j, X_temp, Label_temp)

        # put it together
        pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

        decoded = decoder.predict(pred_input)
        subplot(sides, 6, 1 + img_it)
        img_it +=1
        plt.imshow(decoded.reshape(28, 28), cmap = plt.cm.gray), axis('off')

plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=.2)
plt.show()

"""## Walk across latent space

Interpolate each number, walking from 0 to 75 degrees in the latent space.
"""

def walk_rotation(rot_start, rot_end, num_steps, X_temp, Label_temp):

  z_rot_start = sample_rotation(rot_start, X_temp, Label_temp)
  z_rot_end = sample_rotation(rot_end, X_temp, Label_temp)

  steps = linspace(0, 1, num=num_steps)
  # linear interpolate vectors
  vectors = list()
  for step in steps:
    v = (1.0 - step) * z_rot_start + step * z_rot_end
    vectors.append(v)
  return asarray(vectors)


img_it = 0
sides = 10
Y_temp = Y_full
Y_temp = np.argmax(Y_temp, axis=1)
X_temp = X_full
Label_temp = Label_full
num_steps = 10
for i in range(0, sides):
        
    # slack, prop, rot
    slack_sample = sample_slack(X_temp)
    z_0_digit = sample_digit(i, X_temp, Y_temp)
    rotate_1hot = walk_rotation(0, 5, num_steps, X_temp, Label_temp)

    # plot each step
    for j in range(0, num_steps):

      curr_rotate = rotate_1hot[j,]

      # put it together
      pred_input = np.concatenate([slack_sample[0], z_0_digit[0], curr_rotate[0]]).reshape((1,n_label_z+n_z+n_z))

      decoded = decoder.predict(pred_input)
      subplot(sides, num_steps, 1 + img_it)
      img_it +=1
      plt.imshow(decoded.reshape(28, 28), cmap = plt.cm.gray), axis('off')

plt.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=.2)
plt.show()

"""# **Predict**

Now we train a classification model on 75 degree rotated digits and test it on our reconstructed 75 degree rotated digits.
"""

# train model to classify rotated numbers

# X_train_75, Y_train_75, X_test_75, Y_test_75

Y_argmax_75 = np.argmax(Y_train_75, axis=1)

#choosing the sequential model
classification_model = Sequential()

#defining the architecture of the model
X_class = Input(shape=(n_x))
classification_model.add(X_class)
classification_model.add(Dense(512, activation='relu'))
classification_model.add(Dense(128, activation='relu'))
classification_model.add(Dense(10, activation='softmax'))

#defining the parameters to train the model
classification_model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['accuracy'])

#training the model
classification_model.fit(X_train_75,Y_argmax_75,epochs=5, batch_size=batch_size)

# test model to on our reconstructed test data

num_correct = 0
num_digits = 10
num_rep = 100
acc = []
for digit_idx in range(0, num_digits):
  num_correct = 0
  for idx_rep in range(0, num_rep):
    
    # slack, prop, rot
    slack_sample = sample_slack(X_temp)
    z_0_digit = sample_digit(digit_idx, X_temp, Y_temp)
    rotate_1hot = sample_rotation(5, X_temp, Label_temp)

    # put it together
    pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

    decoded = decoder.predict(pred_input)

    predictions = classification_model.predict(decoded)

    if(digit_idx == np.argmax(predictions)):
      num_correct += 1
  acc = np.append(acc, num_correct)

print(np.mean(acc))
print(acc)

# visualize the reconstructed rotated digit
digit_idx=5
for idx_rep in range(0, 10):
  # slack, prop, rot
  slack_sample = sample_slack(X_temp)
  z_0_digit = sample_digit(digit_idx, X_temp, Y_temp)
  rotate_1hot = sample_rotation(5, X_temp, Label_temp)

  # put it together
  pred_input = np.concatenate([slack_sample[0], z_0_digit[0], rotate_1hot[0]]).reshape((1,n_label_z+n_z+n_z))

  decoded = decoder.predict(pred_input)

  print(f"rotated {digit_idx}")
  plt.imshow(decoder.predict(pred_input).reshape(28,28), cmap = plt.cm.gray), axis('off')
  plt.show()